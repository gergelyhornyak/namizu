<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Drawing App</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            border: 1px solid #ccc;
            margin: 20px auto;
            cursor: crosshair;
            aspect-ratio: 400 / 400;
            touch-action: none; /* Prevent default touch actions */
        }
        .toolbar {
            text-align: center;
            margin-top: 10px;
        }
        .toolbar button, .toolbar input {
            margin: 5px;
            padding: 8px;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Vector Drawing App</h1>
    <canvas id="drawingCanvas" width="400" height="400"></canvas>
    <div class="toolbar">
        <label for="colorPicker">Line Color:</label>
        <input type="color" id="colorPicker" value="#000000" style="padding: 1%">

        <label for="lineWidth">Line Width:</label>
        <input type="number" id="lineWidth" min="1" max="20" value="2">

        <button id="floodFill">Flood Fill</button>
        <button id="clearCanvas">Clear Canvas</button>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthInput = document.getElementById('lineWidth');
        const clearCanvasButton = document.getElementById('clearCanvas');
        const floodFillButton = document.getElementById('floodFill');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let startTouches = [];

        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (touch.clientX - rect.left - offsetX) / scale,
                y: (touch.clientY - rect.top - offsetY) / scale
            };
        }

        // Flood Fill implementation
        function floodFill(x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const width = imageData.width;
            const height = imageData.height;

            const startPos = (y * width + x) * 4;
            const startColor = {
                r: data[startPos],
                g: data[startPos + 1],
                b: data[startPos + 2],
                a: data[startPos + 3],
            };

            const targetColor = {
                r: parseInt(fillColor.slice(1, 3), 16),
                g: parseInt(fillColor.slice(3, 5), 16),
                b: parseInt(fillColor.slice(5, 7), 16),
                a: 255,
            };

            if (rgbaToString(startColor) === rgbaToString(targetColor)) {
                return;
            }

            const stack = [{ x, y }];

            while (stack.length) {
                const { x, y } = stack.pop();

                const currentPos = (y * width + x) * 4;
                const currentColor = {
                    r: data[currentPos],
                    g: data[currentPos + 1],
                    b: data[currentPos + 2],
                    a: data[currentPos + 3],
                };

                if (rgbaToString(currentColor) !== rgbaToString(startColor)) {
                    continue;
                }

                data[currentPos] = targetColor.r;
                data[currentPos + 1] = targetColor.g;
                data[currentPos + 2] = targetColor.b;
                data[currentPos + 3] = targetColor.a;

                if (x > 0) stack.push({ x: x - 1, y });
                if (x < width - 1) stack.push({ x: x + 1, y });
                if (y > 0) stack.push({ x, y: y - 1 });
                if (y < height - 1) stack.push({ x, y: y + 1 });
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function handleStart(event) {
            event.preventDefault();
            if (event.touches && event.touches.length === 1) {
                isDrawing = true;
                const touchPos = getTouchPos(event.touches[0]);
                [lastX, lastY] = [touchPos.x, touchPos.y];
            } else if (event.touches && event.touches.length === 2) {
                startTouches = [...event.touches];
            }
        }

        function handleMove(event) {
            event.preventDefault();
            if (event.touches && event.touches.length === 1 && isDrawing) {
                const touchPos = getTouchPos(event.touches[0]);
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = lineWidthInput.value;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(touchPos.x, touchPos.y);
                ctx.stroke();

                [lastX, lastY] = [touchPos.x, touchPos.y];
            } else if (event.touches && event.touches.length === 2) {
                const [touch1, touch2] = event.touches;
                const startDist = Math.hypot(
                    startTouches[0].clientX - startTouches[1].clientX,
                    startTouches[0].clientY - startTouches[1].clientY
                );
                const currentDist = Math.hypot(
                    touch1.clientX - touch2.clientX,
                    touch1.clientY - touch2.clientY
                );
                const zoomFactor = currentDist / startDist;
                scale *= zoomFactor;
                ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
                startTouches = [...event.touches];
            }
        }

        function handleEnd(event) {
            event.preventDefault();
            if (event.touches.length === 0) {
                isDrawing = false;
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = lineWidthInput.value;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();

            [lastX, lastY] = [e.offsetX, e.offsetY];
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);

        clearCanvasButton.addEventListener('click', () => {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        canvas.addEventListener('click', (e) => {
            if (floodFillButton.dataset.active === 'true') {
                const pos = getTouchPos(e);
                floodFill(pos.x, pos.y, colorPicker.value);
            }
        });

        floodFillButton.addEventListener('click', () => {
            floodFillButton.dataset.active = floodFillButton.dataset.active === 'true' ? 'false' : 'true';
            floodFillButton.style.backgroundColor = floodFillButton.dataset.active === 'true' ? '#ddd' : '';
        });

        canvas.width = 400;
        canvas.height = 400;
    </script>
</body>
</html>

